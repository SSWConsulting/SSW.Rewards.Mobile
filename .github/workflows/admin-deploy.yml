on:
  workflow_call:
    inputs:
      environment:
        required: true
        type: string
      resourceGroupName:
        required: true
        type: string
      frontDoorResourceGroupName:
        type: string
      frontDoorProfileName:
        type: string
      frontDoorEndpointName:
        type: string
      frontDoorDomain:
        type: string
      frontDoorRouteName:
        type: string
    secrets:
      AZURE_CLIENT_ID:
        required: true
      AZURE_SUBSCRIPTION_ID:
        required: true
      AZURE_TENANT_ID:
        required: true

permissions:
  id-token: write
  contents: read

jobs:
  deploy:
    name: Admin - ${{ inputs.environment }}
    runs-on: ubuntu-latest
    environment:
      name: ${{ inputs.environment }}
      url: ${{ steps.bicep.outputs.storageAccountUrl }}

    steps:
      - uses: actions/download-artifact@v4

      - name: Set appsettings.json
        if: ${{ inputs.environment == 'staging' }}
        run: |
          cd ui
          cp appsettings.json appsettings.json.bak
          cp appsettings.${{ inputs.environment }}.json appsettings.json

      - uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          enable-AzPSSession: true

      - name: Deploy Bicep
        id: bicep
        shell: pwsh
        run: |
          $out = az deployment group create `
            --resource-group ${{ inputs.resourceGroupName }} `
            --template-file ./infra/admin-main.bicep `
            --parameters environment=${{ inputs.environment }} `
              | convertfrom-json | foreach properties | foreach outputs

          $out.PSObject.Properties | ForEach-Object {
              $name = $_.Name
              $value = $_.Value.value
              Write-Output "::set-output name=$($name)::$($value)"
          }

      - name: Enable Static Website on Azure Storage
        id: enable-static-site
        shell: pwsh
        run: |
          az storage blob service-properties update `
            --account-name ${{ steps.bicep.outputs.storageAccountName }} `
            --static-website `
            --404-document index.html `
            --index-document index.html

      - name: Get SAS key
        id: storage
        shell: pwsh
        run: |
          $expiry = (Get-Date -AsUTC).AddMinutes(10).ToString('yyyy-MM-ddTHH:mm:ssZ')
          $token = az storage container generate-sas `
            --account-name ${{ steps.bicep.outputs.storageAccountName }} `
            --name '$web' `
            --permissions acdrw `
            --expiry $expiry --https-only --permissions dlrw -o tsv
          Write-Output "::set-output name=sastoken::$($token)"

      # Sync files to blob storage (Front Door handles caching rules)
      - name: Sync files to Azure Blob Storage
        shell: pwsh
        run: |
          az storage blob sync `
            --container '$web' `
            --source "ui" `
            --account-name ${{ steps.bicep.outputs.storageAccountName }} `
            --sas-token "${{ steps.storage.outputs.sastoken }}" `
            --delete-destination true

      # Install Azure CLI extension for Front Door commands
      - name: Install Azure CLI Extension for Front Door
        shell: pwsh
        run: |
          az extension add --name front-door

      # Configure Front Door caching rules (skipped if already exists)
      - name: Configure Front Door Caching Rules
        shell: pwsh
        run: |
          $resourceGroup = "${{ inputs.frontDoorResourceGroupName }}"
          if ([string]::IsNullOrEmpty($resourceGroup)) {
            $resourceGroup = "${{ inputs.resourceGroupName }}"
          }
          $profileName = "${{ inputs.frontDoorProfileName }}"
          $ruleSetName = "BlazorCaching"

          # Check if rule set already exists
          $exists = az afd rule-set show `
            --resource-group $resourceGroup `
            --profile-name $profileName `
            --rule-set-name $ruleSetName 2>$null

          if (-not $exists) {
            Write-Host "Creating rule set: $ruleSetName"
            az afd rule-set create `
              --resource-group $resourceGroup `
              --profile-name $profileName `
              --rule-set-name $ruleSetName

            Write-Host "Creating rule: NoCacheEntryPoints (bypass cache for .html)"
            az afd rule create `
              --resource-group $resourceGroup `
              --profile-name $profileName `
              --rule-set-name $ruleSetName `
              --rule-name "NoCacheEntryPoints" `
              --order 1 `
              --match-variable UrlFileExtension `
              --operator Equal `
              --match-values "html" `
              --action-name RouteConfigurationOverride `
              --cache-behavior Disabled

            Write-Host "Creating rule: NoCacheBootstrap (bypass cache for bootstrap JS)"
            az afd rule create `
              --resource-group $resourceGroup `
              --profile-name $profileName `
              --rule-set-name $ruleSetName `
              --rule-name "NoCacheBootstrap" `
              --order 2 `
              --match-variable UrlPath `
              --operator Contains `
              --match-values "blazor.webassembly.js" "dotnet.js" `
              --action-name RouteConfigurationOverride `
              --cache-behavior Disabled

            Write-Host "Creating rule: LongCacheFramework (7 day cache for /_framework/)"
            az afd rule create `
              --resource-group $resourceGroup `
              --profile-name $profileName `
              --rule-set-name $ruleSetName `
              --rule-name "LongCacheFramework" `
              --order 3 `
              --match-variable UrlPath `
              --operator BeginsWith `
              --match-values "/_framework/" `
              --action-name RouteConfigurationOverride `
              --cache-behavior OverrideAlways `
              --cache-duration "7.00:00:00"
          } else {
            Write-Host "Rule set '$ruleSetName' already exists - skipping rule creation"
          }

          # Always try to associate rule set with route (in case previous attempt failed)
          $routeName = "${{ inputs.frontDoorRouteName }}"
          $endpointName = "${{ inputs.frontDoorEndpointName }}"
          if ($routeName) {
            Write-Host "Associating rule set with route: $routeName"
            az afd route update `
              --resource-group $resourceGroup `
              --profile-name $profileName `
              --endpoint-name $endpointName `
              --route-name $routeName `
              --rule-sets $ruleSetName 2>$null
            Write-Host "✓ Rule set associated with route (or already associated)"
          } else {
            Write-Host ""
            Write-Host "⚠ No frontDoorRouteName provided - manual association required:"
            Write-Host "  Front Door > Endpoints > Routes > Edit > Rule sets > Add '$ruleSetName'"
          }

      # Purge cache after deployment
      - name: Purge Azure Front Door Cache
        shell: pwsh
        run: |
          $resourceGroup = "${{ inputs.frontDoorResourceGroupName }}"
          if ([string]::IsNullOrEmpty($resourceGroup)) {
            $resourceGroup = "${{ inputs.resourceGroupName }}"
          }

          # We won't wait for the purge to complete as it can take 40+ minutes
          # Instead, we try to have smart caching rules on Front Door to minimise the need for purges
          az afd endpoint purge `
            --resource-group $resourceGroup `
            --profile-name ${{ inputs.frontDoorProfileName }} `
            --endpoint-name ${{ inputs.frontDoorEndpointName }} `
            --content-paths '/index.html' '/_framework/blazor.webassembly.js' '/_framework/dotnet.js' '/css/*' '/js/*' '/appsettings.json' '/SSW.Rewards.Admin.AdminUI.styles.css' `
            --domains ${{ inputs.frontDoorDomain }} `
            --no-wait
