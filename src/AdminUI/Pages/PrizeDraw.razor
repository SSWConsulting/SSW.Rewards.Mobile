@page "/Prizedraw"
@using Microsoft.AspNetCore.Authorization
@using Microsoft.AspNetCore.Components.WebAssembly.Authentication
@using SSW.Rewards.Admin.UI.Components
@using SSW.Rewards.Enums
@using SSW.Rewards.Shared.DTOs.Achievements
@using SSW.Rewards.Shared.DTOs.PrizeDraw
@using SSW.Rewards.Shared.DTOs.Rewards
@using SSW.Rewards.ApiClient.Services

@attribute [Authorize (Roles = "Admin")]

@inject IAchievementService AchievementService
@inject IPrizeDrawService PrizeDrawService
@inject IRewardService RewardService
@inject IRewardAdminService RewardAdminService
@inject ISnackbar SnackBar
@inject IJSRuntime JsRuntime
@inject IDialogService DialogService

<MudText Typo="Typo.h2">Prize Draw</MudText>

@if (_loading)
{
    <MudProgressCircular Color="Color.Secondary" Indeterminate="true"/>
}
else
{
    <MudPaper Elevation="2" Class="pa-4 mb-4">

        <MudGrid Spacing="2">
            <MudItem xs="12" sm="6" md="4">
                <MudAutocomplete
                    T="AchievementDto"
                    @bind-Value="@_selectedAchievement"
                    Variant="Variant.Outlined"
                    Margin="Margin.Dense"
                    Dense="true"
                    Label="Required Achievement"
                    AnchorOrigin="Origin.BottomCenter"
                    SearchFuncWithCancel="@SearchAchievements"
                    ShowProgressIndicator="true"
                    ToStringFunc="@GetAchievementName"
                    FullWidth="true"
                />
            </MudItem>

            <MudItem xs="12" sm="6" md="4">
                <MudSelect
                    T="LeaderboardFilter"
                    @bind-Value="@_filter"
                    Margin="Margin.Dense"
                    Dense="true"
                    Label="Players with Points Since"
                    Variant="Variant.Outlined"
                    AnchorOrigin="Origin.BottomCenter"
                    FullWidth="true">
                    @foreach (var when in Enum.GetValues<LeaderboardFilter>())
                    {
                        <MudSelectItem T="LeaderboardFilter" Value="@when">@when.ToString()</MudSelectItem>
                    }
                </MudSelect>
            </MudItem>

            <MudItem xs="12" sm="6" md="4">
                <MudTextField
                    Label="Leaderboard Top X"
                    Variant="Variant.Outlined"
                    Margin="Margin.Dense"
                    Dense="true"
                    Type="InputType.Number"
                    @bind-Value="_top"
                    FullWidth="true"/>
            </MudItem>

            <MudItem xs="8">
                <MudPaper Elevation="0" Class="d-flex flex-wrap gap-4">
                    <MudCheckBox T="bool"
                                 Color="Color.Primary"
                                 Value="_excludeStaff"
                                 Label="Exclude staff"
                                 ValueChanged="(e) => _excludeStaff = e!"/>
                    <MudCheckBox T="bool"
                                 Color="Color.Primary"
                                 Value="_excludePreviousWinners"
                                 Label="Exclude previous winners"
                                 ValueChanged="(e) => _excludePreviousWinners = e!"/>
                </MudPaper>
            </MudItem>

            <MudItem xs="4" Class="d-flex justify-end">
                <MudButton
                    OnClick="@(async () => await LoadEligiblePlayers())"
                    Variant="Variant.Filled"
                    StartIcon="@MudBlazor.Icons.Material.Filled.Search"
                    Size="Size.Medium"
                    Color="Color.Primary">
                    Get eligible winners
                </MudButton>
            </MudItem>
        </MudGrid>
    </MudPaper>
    
    <MudGrid>
        <MudItem xs="12" sm="8">
            <MudGrid Justify="Justify.Center">
                <MudItem>
                    <MudText Typo="Typo.h5" Align="Align.Center">Eligible Players</MudText>
                    <MudText Align="Align.Center">Total: @(_players?.Count ?? 0)</MudText>
                </MudItem>
            </MudGrid>
            
            <MudGrid Spacing="2">
                <MudItem>
                    <MudChipSet MultiSelection="false">
                        @if (_players != null)
                        {
                            @foreach (var player in _players.Select((p, index) => new { p, index }))
                            {
                                <MudChip
                                    Size="Size.Small"
                                    Variant="Variant.Text"
                                    Color="@_colors[player.index % _colors.Length]">@(player.p.Name)</MudChip>
                            }   
                        }
                    </MudChipSet>
                </MudItem>
            </MudGrid>

            @if (_isDrawingPrize)
            {
                <MudDivider DividerType="DividerType.Middle" Class="my-12"/>
            
                <MudGrid Justify="Justify.Center">
                    <MudItem>
                        <MudText Align="Align.Center">
                            Shuffling things around...
                        </MudText>
                        <MudText Align="Align.Center">
                            <MudProgressCircular Color="Color.Success" Indeterminate="true"/>
                        </MudText>
                    </MudItem>
                </MudGrid>    
            }
            
            @if (_players is {Count: > 0 } && !_isDrawingPrize)
            {
                <MudDivider DividerType="DividerType.Middle" Class="my-6"/>

                <MudGrid Spacing="2" Justify="Justify.Center">
                    <MudItem>
                        <MudButton
                            OnClick="DrawPrizeWinner"
                            Variant="Variant.Filled"
                            StartIcon="@MudBlazor.Icons.Material.Filled.Celebration"
                            Color="Color.Primary"
                            Style="width: 400px; height: 60px;">
                            Draw prize winner!
                        </MudButton>
                    </MudItem>
                </MudGrid>    
            }
        </MudItem>

        <MudItem xs="12" sm="4">
            <MudPaper Elevation="3" Class="pa-4 ml-2 mb-2">
                <div class="d-flex justify-space-between align-center mb-2">
                    <MudText Typo="Typo.h5">Previous Winners</MudText>
                    @if (_previousWinners.Count > 0)
                    {
                        <MudButton
                            StartIcon="@MudBlazor.Icons.Material.Filled.Clear"
                            Color="Color.Error"
                            Size="Size.Small"
                            Variant="Variant.Outlined"
                            OnClick="@(async () => await ClearPreviousWinners())">
                            Clear
                        </MudButton>
                    }
                </div>
                <MudDivider Class="mb-3"/>
                <div class="d-flex flex-column gap-2">
                    @if (_previousWinners.Count > 0)
                    {
                        foreach (var winner in _previousWinners)
                        {
                            <div class="d-flex align-center pa-1 gap-2">
                                <MudIcon Icon="@MudBlazor.Icons.Material.Filled.EmojiEvents" Color="Color.Success" Size="Size.Small"/>
                                <MudText Typo="Typo.body1" Color="Color.Success">@winner.Name</MudText>
                            </div>
                        }
                    } else
                    {
                        <MudText Typo="Typo.body2" Color="Color.Info" Class="pa-2 text-center">
                            No previous winners recorded
                        </MudText>
                    }
                </div>
            </MudPaper>
        </MudItem>

    </MudGrid>
}

@code {
    private readonly Color[] _colors = { Color.Primary, Color.Secondary, Color.Tertiary, Color.Info, Color.Warning, Color.Success, Color.Error };
    private SessionStorage _storage;

    private static int PrizeDrawSuspenseDelay => 2500;
    private bool _loading = false;
    private bool _isDrawingPrize = false;

    private List<EligibleUserDto>? _players = [];
    AchievementDto? _selectedAchievement;
    private LeaderboardFilter _filter = LeaderboardFilter.Today;
    private int _top;
    private bool _excludeStaff = true;
    private List<Winner> _previousWinners = [];
    private bool _excludePreviousWinners = true;

    protected override async Task OnInitializedAsync()
    {
        await base.OnInitializedAsync();
        _storage = new SessionStorage(JsRuntime);
        await LoadPreviousWinners();
    }

    private async Task LoadPreviousWinners()
    {
        _previousWinners = await _storage.LoadWinners();
    }

    private async Task<IEnumerable<AchievementDto>> SearchAchievements(string value, CancellationToken cancellationToken)
    {
        var achievements = await AchievementService.SearchAchievements(value, cancellationToken);

        return achievements.Achievements;
    }

    private async Task LoadEligiblePlayers()
    {
        try
        {
            _loading = true;

            var (dateFrom, dateTo) = GetDateRangeForFilter(_filter);

            var filter = new GetEligibleUsersFilter
            {
                AchievementId = _selectedAchievement?.Id,
                DateFrom = dateFrom,
                DateTo = dateTo,
                FilterStaff = _excludeStaff,
                Top = _top,
            };

            var eligibleUsersVm = await PrizeDrawService.GetEligibleUsers(filter, CancellationToken.None);
            var eligiblePlayers = eligibleUsersVm.EligibleUsers.ToList();

            if (_excludePreviousWinners)
            {
                var previousWinnerIds = _previousWinners.Select(w => w.Id).ToHashSet();
                eligiblePlayers = eligiblePlayers
                    .Where(p => !previousWinnerIds.Contains(p.UserId.ToString()))
                    .ToList();
            }

            _players = eligiblePlayers;
            _loading = false;
        }
        catch (AccessTokenNotAvailableException exception)
        {
            exception.Redirect();
        }
    }
    
    private async Task DrawPrizeWinner()
    {
        _isDrawingPrize = true;
        await InvokeAsync(StateHasChanged);
        await Task.Delay(PrizeDrawSuspenseDelay);
        
        var eligiblePlayers = _players?.ToList() ?? [];

        if (!eligiblePlayers.Any())
        {
            SnackBar.Add("No eligible players remaining!", Severity.Warning);
            _isDrawingPrize = false;
            return;
        }

        Random rand = new();
        var winner = eligiblePlayers.ElementAt(rand.Next(eligiblePlayers.Count()));
        _isDrawingPrize = false;
        
        var parameters = new DialogParameters
        {
            ["Winner"] = winner,
            ["OnClaimPrize"] = EventCallback.Factory.Create<(EligibleUserDto, RewardDto)>(this,
                async args => await ClaimPrizeForWinner(args.Item1, args.Item2)),
            ["OnSkipWinner"] = EventCallback.Factory.Create<EligibleUserDto>(this,
                async user => await SkipWinner(user))
        };
        
        var options = new DialogOptions
        {
            CloseOnEscapeKey = false,
            DisableBackdropClick = true,
            MaxWidth = MaxWidth.Medium,
            FullWidth = true
        };
        
        var dialog = await DialogService.ShowAsync<WinnerDialog>("Prize Winner!", parameters, options);
        await dialog.Result;
    }

    private async Task ClaimPrizeForWinner(EligibleUserDto winner, RewardDto reward)
    {
        var result = await RewardAdminService.ClaimForUser(reward.Code, winner.UserId ?? 0, false, CancellationToken.None);
    
        if (result.status == RewardStatus.Claimed)
        {
            if (winner.UserId != null)
            {
                await _storage.SaveWinner(winner.UserId.ToString(), winner.Name ?? string.Empty);
                await LoadPreviousWinners();
            }
    
            SnackBar.Add($"{reward.Name} successfully claimed for {winner.Name}!", Severity.Success, options =>
            {
                options.VisibleStateDuration = 10000;
            });
    
            _players?.RemoveAll(p => p.UserId == winner.UserId);
        }
        else
        {
            SnackBar.Add($"Could not claim reward!\n\n{result.status}", Severity.Error);
        }
    }
    
    private async Task SkipWinner(EligibleUserDto winner)
    {
        _players?.RemoveAll(p => p.UserId == winner.UserId);
        
        // Only auto-draw another winner if there are still players left
        if (_players?.Count > 0)
        {
            await DrawPrizeWinner();
        }
        else
        {
            SnackBar.Add("No eligible players remaining!", Severity.Warning);
        }
    }

    private static string GetAchievementName(AchievementDto? achievement)
    {
        return achievement?.Name ?? string.Empty;
    }

    private async Task ClearPreviousWinners()
    {
        await _storage.ClearWinners();
        _previousWinners.Clear();
        SnackBar.Add("Previous winners cleared!", Severity.Success);
    }

    private static (DateTime? from, DateTime? to) GetDateRangeForFilter(LeaderboardFilter filter)
    {
        var now = DateTime.Now; // Client's local timezone

        var (localFrom, localTo) = filter switch
        {
            LeaderboardFilter.Today => (now.Date, now.Date.AddDays(1).AddTicks(-1)),
            LeaderboardFilter.ThisWeek => (now.Date.AddDays(-(int)now.DayOfWeek),
                now.Date.AddDays(7 - (int)now.DayOfWeek).AddTicks(-1)),
            LeaderboardFilter.ThisMonth => (new DateTime(now.Year, now.Month, 1),
                new DateTime(now.Year, now.Month, 1).AddMonths(1).AddTicks(-1)),
            LeaderboardFilter.ThisYear => (new DateTime(now.Year, 1, 1),
                new DateTime(now.Year + 1, 1, 1).AddTicks(-1)),
            LeaderboardFilter.Forever => (null, null),
            _ => ((DateTime?)null, (DateTime?)null)
        };

        // Convert local times to UTC for server processing
        if (localFrom.HasValue && localTo.HasValue)
        {
            return (localFrom.Value.ToUniversalTime(), localTo.Value.ToUniversalTime());
        }

        return (null, null);
    }

    private class Winner
    {
        public string Id { get; set; } = string.Empty;
        public string Name { get; set; } = string.Empty;
    }
    
    private class SessionStorage(IJSRuntime jsRuntime)
    {
        private const string PreviousWinnersKey = "ssw-rewards-previous-winners";
    
        public async Task<List<Winner>> LoadWinners()
        {
            var winnersJson = await jsRuntime.InvokeAsync<string>("sessionStorage.getItem", PreviousWinnersKey);
            if (string.IsNullOrEmpty(winnersJson))
                return [];
    
            var winners = System.Text.Json.JsonSerializer.Deserialize<List<Winner>>(winnersJson);
            return winners ?? [];
        }
    
        public async Task SaveWinner(string userId, string name)
        {
            var winners = await LoadWinners();
            winners.Add(new Winner { Id = userId, Name = name });
            var winnersJson = System.Text.Json.JsonSerializer.Serialize(winners);
            await jsRuntime.InvokeVoidAsync("sessionStorage.setItem", PreviousWinnersKey, winnersJson);
        }

        public async Task ClearWinners()
        {
            await jsRuntime.InvokeVoidAsync("sessionStorage.removeItem", PreviousWinnersKey);
        }
    }
}